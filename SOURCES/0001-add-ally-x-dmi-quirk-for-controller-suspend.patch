From bb91e2a266689d3549d06c0db57d898fce7cfd89 Mon Sep 17 00:00:00 2001
From: antheas <git@antheas.dev>
Date: Sun, 21 Jul 2024 22:15:10 +0300
Subject: [PATCH v2] allyx: switch to lps0 delay for controller suspend

---
 drivers/platform/x86/asus-wmi.c | 86 ++++++++++++++++++---------------
 1 file changed, 48 insertions(+), 38 deletions(-)

diff --git a/drivers/platform/x86/asus-wmi.c b/drivers/platform/x86/asus-wmi.c
index 4b78c4f..0345d52 100644
--- a/drivers/platform/x86/asus-wmi.c
+++ b/drivers/platform/x86/asus-wmi.c
@@ -144,10 +144,24 @@ module_param(fnlock_default, bool, 0444);
 #define ASUS_MINI_LED_2024_STRONG	0x01
 #define ASUS_MINI_LED_2024_OFF		0x02
 
-/* Controls the power state of the USB0 hub on ROG Ally which input is on */
+/*  
+ * For Ally and Ally X, which are handheld consoles with controllers:
+ * 
+ * This function yanks the controller before suspend to fix Modern Standby in
+ * Windows. Due to the linux caller implementation of the relevant _DSM function
+ * which calls CSEE (named Display On and Off) Linux calls it both too close to
+ * suspend and too close out of suspend. This causes the MCU to either get 
+ * confused or ignore the restore command. If it gets confused, both the yank 
+ * (arg0 is b7) and restore (arg0 is b8) need to be called in sequence. If it 
+ * ignores the command, only the restore needs to be called.
+ * 
+ * Therefore, we require LSP0 to wait for a bit before suspending after yanking
+ * the controllers and wait a bit before restoring them on on resume, to let 
+ * the MCU prepare for suspend and re-initialize properly after suspend. 
+ */
 #define ASUS_USB0_PWR_EC0_CSEE "\\_SB.PCI0.SBRG.EC0.CSEE"
-/* 300ms so far seems to produce a reliable result on AC and battery */
-#define ASUS_USB0_PWR_EC0_CSEE_WAIT 1500
+#define ASUS_USB0_PWR_EC0_CSEE_PREPARE 1200
+#define ASUS_USB0_PWR_EC0_CSEE_RESTORE 1200
 
 static const char * const ashs_ids[] = { "ATK4001", "ATK4002", NULL };
 
@@ -284,9 +298,6 @@ struct asus_wmi {
 	u32 tablet_switch_dev_id;
 	bool tablet_switch_inverted;
 
-	/* The ROG Ally device requires the MCU USB device be disconnected before suspend */
-	bool ally_mcu_usb_switch;
-
 	enum fan_type fan_type;
 	enum fan_type gpu_fan_type;
 	enum fan_type mid_fan_type;
@@ -4617,6 +4628,21 @@ static void init_rog_tunables(struct asus_wmi *asus)
 
 }
 
+static void asus_wmi_ally_s2idle_prepare(void)
+{
+	msleep(ASUS_USB0_PWR_EC0_CSEE_PREPARE);
+}
+
+static void asus_wmi_ally_s2idle_restore(void)
+{
+	msleep(ASUS_USB0_PWR_EC0_CSEE_RESTORE);
+}
+
+static struct acpi_s2idle_dev_ops asus_wmi_ally_s2idle_dev_ops = {
+	.prepare = asus_wmi_ally_s2idle_prepare,
+	.restore = asus_wmi_ally_s2idle_restore,
+};
+
 static int asus_wmi_add(struct platform_device *pdev)
 {
 	struct platform_driver *pdrv = to_platform_driver(pdev->dev.driver);
@@ -4646,8 +4672,20 @@ static int asus_wmi_add(struct platform_device *pdev)
 	asus->egpu_enable_available = asus_wmi_dev_is_present(asus, ASUS_WMI_DEVID_EGPU);
 	asus->dgpu_disable_available = asus_wmi_dev_is_present(asus, ASUS_WMI_DEVID_DGPU);
 	asus->kbd_rgb_state_available = asus_wmi_dev_is_present(asus, ASUS_WMI_DEVID_TUF_RGB_STATE);
-	asus->ally_mcu_usb_switch = acpi_has_method(NULL, ASUS_USB0_PWR_EC0_CSEE)
-						&& dmi_match(DMI_BOARD_NAME, "RC71L");
+
+	bool ally_mcu_usb_switch =
+		acpi_has_method(NULL, ASUS_USB0_PWR_EC0_CSEE) &&						
+		(dmi_match(DMI_BOARD_NAME, "RC71L") ||
+		 dmi_match(DMI_BOARD_NAME, "RC72LA"));
+
+	if (ally_mcu_usb_switch && IS_ENABLED(CONFIG_SUSPEND)) {
+		err = acpi_register_lps0_dev(&asus_wmi_ally_s2idle_dev_ops);
+		if (err)
+			dev_err(&pdev->dev,
+				"Ally MCU: failed to register LPS0 sleep delays, a race condition might prevent controller restore after sleep.\n");
+		else
+			dev_info(&pdev->dev, "Ally MCU: registered LPS0 sleep delays for resuming controller after sleep.\n");
+	}
 
 	if (asus_wmi_dev_is_present(asus, ASUS_WMI_DEVID_MINI_LED_MODE))
 		asus->mini_led_dev_id = ASUS_WMI_DEVID_MINI_LED_MODE;
@@ -4838,34 +4876,6 @@ static int asus_hotk_resume(struct device *device)
 	return 0;
 }
 
-static int asus_hotk_resume_early(struct device *device)
-{
-	struct asus_wmi *asus = dev_get_drvdata(device);
-
-	if (asus->ally_mcu_usb_switch) {
-		/* sleep required to prevent USB0 being yanked then reappearing rapidly */
-		if (ACPI_FAILURE(acpi_execute_simple_method(NULL, ASUS_USB0_PWR_EC0_CSEE, 0xB8)))
-			dev_err(device, "ROG Ally MCU failed to connect USB dev\n");
-		else
-			msleep(ASUS_USB0_PWR_EC0_CSEE_WAIT);
-	}
-	return 0;
-}
-
-static int asus_hotk_prepare(struct device *device)
-{
-	struct asus_wmi *asus = dev_get_drvdata(device);
-
-	if (asus->ally_mcu_usb_switch) {
-		/* sleep required to ensure USB0 is disabled before sleep continues */
-		if (ACPI_FAILURE(acpi_execute_simple_method(NULL, ASUS_USB0_PWR_EC0_CSEE, 0xB7)))
-			dev_err(device, "ROG Ally MCU failed to disconnect USB dev\n");
-		else
-			msleep(ASUS_USB0_PWR_EC0_CSEE_WAIT);
-	}
-	return 0;
-}
-
 static int asus_hotk_restore(struct device *device)
 {
 	struct asus_wmi *asus = dev_get_drvdata(device);
@@ -4910,8 +4920,6 @@ static const struct dev_pm_ops asus_pm_ops = {
 	.thaw = asus_hotk_thaw,
 	.restore = asus_hotk_restore,
 	.resume = asus_hotk_resume,
-	.resume_early = asus_hotk_resume_early,
-	.prepare = asus_hotk_prepare,
 };
 
 /* Registration ***************************************************************/
@@ -4972,6 +4980,8 @@ void asus_wmi_unregister_driver(struct asus_wmi_driver *driver)
 {
 	platform_device_unregister(driver->platform_device);
 	platform_driver_unregister(&driver->platform_driver);
+	if (IS_ENABLED(CONFIG_SUSPEND))
+		acpi_unregister_lps0_dev(&asus_wmi_ally_s2idle_dev_ops);
 	used = false;
 }
 EXPORT_SYMBOL_GPL(asus_wmi_unregister_driver);
-- 
2.45.2

